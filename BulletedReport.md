# Introduction
This text-based choose your own adventure game was created by Michael Brown and Carl Porter, III on December 2nd, 2023. The project was created to entertain Dr. Jamieson and our fellow students as the game places the user in the shoes of a student taking an ECE 287 exam. The game is not serious and involves the user succeeding or failing in different comical ways. There are twenty four game states with nine endings. We greatly enjoyed creating this game and hope that everyone that plays it enjoys it.
# Functionality
## Control
- Switch 17 is our reset signal and resets the system when it is in the off position.
- The push button keys allow the user to make an input. The inputs are four to one from left to right.
## VGA
### VGA States
NOTE: All states transition after one clock cycle in the order listed unless otherwise noted.

- START initializes all variables to a known state.
- W2M_INIT initializes the variables used in writing data to the buffers to zero and enables writing to the buffer. Finally, character_buf_mem_address is assigned the first seven-bit address of frame as it takes a clock cycle for the frame variable to update. Thus, character_buf_mem_address must be assigned here to be accurate and not in START.
- W2M_COND waits for the writing to be complete by waiting for the counter i to reach the size of the memory. It transitions to W2M_INC if there is more data to write or W2M_DONE if there is no more data to write.
- W2M_INC increments the counter i and the memory address while writing a solid color to the display depending on switches sixteen to fourteen. This is irrelevant as it will only be displayed for a frame before the game data is displayed from the later write and read logic.
- W2M_DONE turns off writing to the buffer and initializes the read_buf_mem_address to zero. Finally, it initializes current_character to the data output by the CharacterArray.v module as this data was not accurate in the START state or the W2M_INIT state as it takes multiple clock cycles for the data output from the CharacterArray.v module to be accurate once character_buf_mem_address is updated. This state loops before transitioning to RFM_INIT_START when frame_done is equal to one. This signal is one when the vga_driver.v module finishes writing to the display.
- RFM_INIT_START resets all the write variables to zero and assigns current_current character again. This is the state where frame is updated to display new data or redisplay the current data. completedFirstCycle is assigned zero so the data being written can be initialized in the next state. The wr_id variable is assigned here which controls which buffer is currently being read from and which buffer is being written to. Finally, the first instance of the read logic is included. See the read logic section for more information.
- RFM_INIT_WAIT contains the read logic and a structure to initialize the data to be written to the buffer not being read from. This structure depends on the completedFirstCycle variable being zero so that it only executes once. In this structure, data is written to write_buf_mem_address location zero so that location has the accurate data and is not written with data from the end of the last write cycle. In this structure, current_character, frame, character_buf_mem_address, and counterPixels go through their first incrementation. See the Data Writing section for more information. RFM_INIT_WAIT transitions to RFM_DRAWING if frame_done is equal to zero which means the vga_driver.v module is ready to draw the next frame. Otherwise, it loops.
- RFM_DRAWING contains the write logic and the read logic structures as well as the data structure. See the respective sections for more information.
### VGA Buffer Writing Structure
The VGA buffer writing logic works as follows. 
- counterPixels, counterLines, and character_count are counters to control timing and the value of write_buf_mem_address.
- counterPixels counts how many addressable pixels (only a 160x120 frame can be stored in the buffers while the vga_display is written at 640x480) have passed so counterLines can be incremented by one and write_buf_mem_address can be incremented by 151 which brings it to the next line of our ten by ten pixel boxes that each character is written into. counterPixels is then reset to zero.
- counterLines counts how many lines in each of our ten by ten pixel boxes have been written. Once this value reaches nine, we reset counterLines and counterPixels as both must be at nine before this condition is reached and we subtract 1439 from the write_buf_mem_address to move the writing to the next ten by ten pixel box. Finally, we increment character_count by one.
- character_count counts how many ten by ten pixel boxes we have finished writing. When counterPixels and counterLines are both equal to nine and character_count is equal to fifteen, we reset all of the counters to zero. The, we increment write_buf_mem_address by one to bring writing to the next line of ten by ten pixel boxes. 
- Finally, when counterPixels and counterLines are both equal to nine, character_count is equal to fifteen, and write_buf_mem_address is greater than or equal to 19199 (the final memory location for the frame) we reset all of the counters and write_buf_memory address. Further, character_done which is part of the data writing logic is set to zero and character_buf_mem_address is set to the first address in frame which was reset before this.
- This whole structure and the data writing structure are dependant on write_buf_mem_wren being one. If it is not, then all of this is ignored and write_buf_mem_wren is kept zero, character_buf_mem_address is assigned the first address in frame and frame is reset.
### VGA Data Writing Structure
The VGA buffer data writing logic functions as follows:
- write_buf_mem_data is the bus that transmits the data to memory. 
- current_character contains the data to draw each character that is stored in the CharacterArray.v Quartus IP memory module. If current_character's least significant bit is equal to one than white is written to memory. If not, blue is written. current_character is shifted to the right by one in both cases so that the encoded data in the variable can be read sequentially.
- The above logic is executed if character_done is equal to zero which is true until the final line of each character box at the second to last location as counted by counterPixels. It takes a clock cycle to updata the character_done variable which executes the following logic at the final location in each character box.
- When character_done is one, the final value is written to the character box using the same logic as above. In addition, character_buf_mem_address is assigned the seven most significant bits of frame and frame is shifted to the left by seven bits to prepare the next value. character_buf_mem_address is always ahead of current_character by one character which ensure the data being output to current_character is accurate when it is assigned in this area. The same is true for frame. Finally, if the final character of the frame has been written then frame is set to the value being input from the game.v module. Otherwise, frame is shifted left by seven bits. 
### VGA Read Structure
The VGA buffer reading logic is as follows:
- readCounter, readCounterOverall, and readLineCounter are used to control read_buf_mem_address which outputs data to the vga_driver.v module that writes to the display.
- readCounter counts clock cycles to increment readCounterOverall and control read_buf_mem_address. It increments readCounterOverall on odd clock cycles so readCounterOverall matches the value of the x coordinate of the display as it changes every even value. readCounter increments read_buf_mem_address every seventh clock cycle so read_buf_mem_data can be accurate for the next four pixels. On the eigth clock cycle, readCounter is reset.
- readCounterOverall counts how many pixels have been written to in each line to increment readLineCounter. When readcounter is equal to six and readCounterOverall is equal to 639, read_buf_mem_address is reset to reread the same line of data. When readcounter is equal to seven and readCounterOverall is equal to 639, readLineCounter is incremented by one.
-readLineCounter counts how many times the same line of memory data has been read. To downscale the resolution, each line of memory must be read four times to complete the vertical component of each addressable pixel. When readcounter is equal to six, readCounterOverall is equal to 639, and readLineCounter is greater than or equal to three, then read_buf_mem_address is incremented by one to read the next line of data. When readcounter is equal to seven, readCounterOverall is equal to 639, and readLineCounter is greater than or equal to three, then they are all reset.
### VGA Data Variables
- The frame variable is updated in the game.v module depending on the state and is passed to the vga_driver_memory_double_buf.v module through the FinalProject.v module.
- The frame variable contains 192 7-bit addresses that are used to reference the data stored in the CharacterArray.v Quartus IP memory module.
- character_buf_mem_address in the vga_driver_memory_double_buf.v module updates current_character with the data to draw each character.
# Citations
Dr. Peter Jamieson provided the vga_driver_memory_double_buf.v module and subsidiary files that were modified to work with our project.